/**
   * @license
   * author: Richard Shephard
   * stencil-tailwind-plugin.js v1.8.0
   * Released under the MIT license.
   */
import n from"path";import t from"fs-extra";import e from"chalk";import i from"p-queue";import r,{ScriptTarget as s,SyntaxKind as o}from"typescript";import c from"postcss";import a from"autoprefixer";import u from"tailwindcss/lib/processTailwindFeatures";import l from"tailwindcss/lib/public/resolve-config";import f from"postcss-load-config";import d from"cssnano";import p from"postcss-combine-duplicated-selectors";import m from"postcss-discard-comments";let g=!1;function w(...n){g&&console.log(e.bold.blue("[DBG]"),...n)}function b(...n){console.log(e.bold.bgRedBright("[ERR]"),e.bold.red(...n))}const h={DEFAULT:{enableDebug:!1,tailwindCssPath:void 0,tailwindCssContents:"@tailwind base;@tailwind utilities;@tailwind components;",tailwindConf:{content:[],theme:{extend:{}},plugins:[]},stripComments:!1,minify:!0,useAutoPrefixer:!0}};function y(i){const r=t.readFileSync(n.resolve(i)).toString();return 0===r.length?(function(...n){console.log(e.bold.yellowBright("[WRN]"),...n)}("No css found when reading Tailwind configuration css - path",i),null):r}function x(n){var t;const e=Object.assign({},n);if(e.tailwindCssPath&&(e.tailwindCssContents=null!==(t=y(e.tailwindCssPath))&&void 0!==t?t:e.tailwindCssContents),"function"!=typeof e.tailwindConf){const n=e.tailwindConf;e.tailwindConf=function(n){return(t,e)=>{var i;const r=e.corePlugins.preflight;let s=r;return Array.isArray(n.corePlugins)?Object.assign(Object.assign(Object.assign({},n),e),{corePlugins:[]}):(r&&n.corePlugins&&(s=null===(i=n.corePlugins.preflight)||void 0===i||i),Object.assign(Object.assign({},n),{content:e.content,corePlugins:Object.assign(Object.assign({},n.corePlugins),{preflight:s})}))}}(n)}return e}function S(n){return r.createSourceFile("placeholder.ts",n,s.Latest)}function E(n){return function(t,e){const i=n[e];if(i&&t.kind===i.nodeKind){if(i.has){if(!t.modifiers)return!1;let n=!1;for(let e=0;e<t.modifiers.length;++e)if(t.modifiers[e].kind===i.has){n=!0;break}if(!n)return!1}return i.name?t.name&&t.name.escapedText===i.name:!i.initializerKind||t.initializer&&t.initializer.kind===i.initializerKind}return!1}}function O(n,t){const e=E(t);let i=0;return function n(s){return e(s,i)&&(i++,i===t.length)?s:r.forEachChild(s,n)}(n)}function T(n,{name:t,modifier:e,initializer:i}={}){return{nodeKind:n,name:t,has:e,initializerKind:i}}function C(n,t){let e=0;const i=E(n);return function(s){function c(a){return w("[Typescript]","Visiting "+o[a.kind]),i(a,e)?(e++,e===n.length?t(a):(w("[Typescript]","Moving to next tree level",e,"looking for",o[n[e].nodeKind]),a=r.visitEachChild(a,c,s))):a}return function(n){return r.visitNode(n,c)}}}function P(n,t){return n.findIndex((n=>"function"==typeof n&&n.name===t||"object"==typeof n&&null!==n&&(n.postcssPlugin===t||n.name===t)))}function v(){return m({removeAll:!0})}function j(){return[p(),d()]}async function F(n){const t=await async function(n){const t={plugins:[]};let e="";if("object"==typeof n&&!Array.isArray(n)&&null!==n&&Array.isArray(n.plugins))return n.plugins;("string"==typeof n||n instanceof String)&&(e=n);try{return(await f(t,e)).plugins}catch(t){if("MODULE_NOT_FOUND"===t.code)throw new Error(`'stencil-tailwind-plugin' is not able to resolve modules required from configuration files. Make sure it is installed\nError: ${t.message}`);w("[TW]","No postcss configuration file found in:",n)}return[]}(n.postcss),e=P(t,"tailwindcss"),i=-1!==P(t,"autoprefixer");return{before:-1===e?[]:t.slice(0,e),after:-1===e?t:t.slice(e+1),hasAutoPrefixer:i}}async function R(n,t,e,i){const r=function(n,t,e){return n(t[0],{content:t,corePlugins:{preflight:e}})}(n.tailwindConf,[t],i),{before:s,after:o,hasAutoPrefixer:c}=await F(n),f=[...s,function(n,t){const e=()=>({postcssPlugin:"tailwindcss",Once(e,{result:i}){u((({createContext:e})=>()=>e(l(n),[t])))(e,i)}});return e.postcss=!0,e}(r,{content:e,extension:"tsx"}),...o];return n.useAutoPrefixer&&!c&&f.push(a()),n.minify&&f.push(...j()),n.stripComments&&f.push(v()),f}async function A(n,t,e,i,r){const s=`${n.tailwindCssContents} ${null!=r?r:""}`,o=await R(n,e,i,t),a=function(n,t){return t?n:n.replace(/\n/g,"").replace(/'/g,'"').replace(/`/g,"\\`").replace(/\t/g," ")}((await c(o).process(s,{from:e})).css,n.minify);return w("[TW]","Tailwind styles:",a),a}function D(n,t,e,i){return A(n,!1,t,e,i)}function k(n,t,e,i){return A(n,!0,t,e,i)}async function z(t,e,i,r){const{minify:s,stripComments:o}=t,a=i+r;if(!s||0===r.length)return a;const u=n.join(".",n.relative(process.cwd(),e)),l=j();o&&l.push(v());return(await c(l).process(a,{from:u})).css}const $=[];function L(n){return n.replace(/\\/g,"/")}function V(t){const e=n.parse(t);return L(n.join(e.dir,e.name))}function K(n,t){const e=L(n),i=t.map(V),r=function(n){return $.find((t=>t.name===n))}(e);if(void 0===r)return w("[STORE]","Registered",i,"with",e),void $.push(function(n,t){return{imports:t,cssFiles:{},name:n}}(e,i));w("[STORE]","Updated",i,"with",e),r.imports.push(...i)}function N(n,t){const e=L(n);w("[STORE]","Registering css for",e,"against",t);const i=function(n){const t=V(n);return function(e){return-1!==e.imports.indexOf(t)||e.name===n}}(e);$.forEach((n=>{i(n)&&(w("[STORE]","Found cross reference for imported file",n.name,"to store css against"),n.cssFiles[e]={name:e,css:t})}))}function B(n){const t=L(n);w("[STORE]","Looking up import of",t);const e=function(n){const t=V(n);return w("[STORE]","Import spec for matching",t),$.filter((n=>n.imports.includes(t)))}(t).reduce(((n,t)=>(n.css+=Object.entries(t.cssFiles).reduce(((t,[e,i])=>(t+=i.css,n.dependencies.push(i.name),t)),""),n)),{css:"",dependencies:[]});return w("[STORE]","Injecting css",e),e}function I(n){return async(t,e)=>{w("[Stylesheets]","Processing css from tsx source file:",e);const i=S(t),s=await async function(n,t,e,i){const s=[T(o.SourceFile),T(o.FirstStatement),T(o.VariableDeclarationList),T(o.VariableDeclaration),T(o.StringLiteral)],c=B(i).css,a=O(t,s);return await(async t=>{const r=t.text,s=await k(n,i,e,r),o=await z(n,i,s,c);t.text=o})(a),r.createPrinter().printFile(t)}(n,i,t,e);return s}}function U(){return[T(o.SourceFile),T(o.VariableStatement),T(o.VariableDeclarationList),T(o.VariableDeclaration,{initializer:o.ClassExpression})]}function M(n,t){const e=U();let i="";const s=function(n,t,e){let i=!1;const s=r.transform(n,[C(t,(function(n){return w("Found Node, calling user processing"),i=!0,e(n)}))]),[o]=s.transformed,c=r.createPrinter();return{found:i,fullText:c.printFile(o)}}(n,e,(n=>{const t=n;return t.name&&t.initializer&&t.initializer.kind===o.ClassExpression&&(i=t.name.escapedText),n}));if(s.found){const n=r.factory.createIdentifier(`'${t}'`);s.fullText=`${s.fullText}${i}.style = ${n.escapedText};\n`}return s}function W(t,e){const i=n.parse(e),s=[];!function(n,t,e){(function n(i){return i.kind===t&&e(i)?i:r.forEachChild(i,n)})(n)}(t,o.ImportDeclaration,(function(t){const e=t.moduleSpecifier,r=n.resolve(i.dir,e.text);return s.push(r),!1})),K(e,s)}function q(n){return!function(n){return void 0!==O(n,[T(o.SourceFile),T(o.VariableStatement,{modifier:o.ExportKeyword}),T(o.VariableDeclarationList),T(o.VariableDeclaration),T(o.ClassExpression),T(o.GetAccessor,{name:"style",modifier:o.StaticKeyword}),T(o.Block),T(o.ReturnStatement)])}(n)&&!function(n){return void 0!==O(n,[T(o.SourceFile),T(o.ExpressionStatement),T(o.BinaryExpression)])}(n)}function G(n){return async(t,e)=>{w("[Typescript]","Processing source file:",e);const i=S(t),r=q(i),s=r&&function(n){return void 0!==O(n,U())}(i)?k:D,o=await s(n,e,t);if(0===o.length)return t;const c=o.replace(/\\/g,"\\\\");if(W(i,e),r){const n=function(n,t){const e=M(n,t);return{text:e.fullText,transformed:e.found}}(i,c);if(n.transformed)return n.text}return N(e,o),t}}function _(){w("Starting build")}function H(n){n&&(b("Oh noes! Something went wrong!",n.message),b(n.stack)),w("Build completed")}const J=new i({concurrency:1});function Q(n){const t=G(n),e=I(n);return async(n,i)=>await J.add((async()=>{let r=n;return i.match(/\.s?(a|c)ss$/)?r=await e(n,i):function(n){return n.match(/\.tsx/)}(i)&&(r=await t(n,i)),{code:r,map:null}}))}function X(n){const t=function(n){return async(t,e)=>{w("[Stylesheets]","Processing css source file:",e);const i=B(e).css,r=await k(n,e,t,t);return await z(n,e,r,i)}}(n);return async(n,e)=>await J.add((async()=>{const i=B(e);return{code:await t(n,e),map:null,dependencies:i.dependencies}}))}function Y(t){return async(e,i,r)=>{if(!r.config.globalStyle)return{code:e,map:null};const s=n.parse(r.config.globalStyle),o=new RegExp(`${s.dir}.${s.name}.s?(a|c)ss`);return i.match(o)?await J.add((async()=>({code:await k(t,i,e,e),map:null,dependencies:[r.config.globalStyle,i]}))):{code:e,map:null}}}const Z=Object.freeze(h);let nn=Z.DEFAULT;function tn(n){const t=Object.assign(Object.assign({},nn),n),e=x(t);var i;return i=t.enableDebug,g=i,e}function en(n){return{name:"tailwind",transform:Q(tn(n)),buildStart:_,buildEnd:H}}function rn(n){return nn=Object.assign(Object.assign({},nn),n),nn}function sn(n){return{pluginType:"css",name:"tailwind-hmr",transform:X(tn(n)),buildStart:_,buildEnd:H}}function on(n){return{pluginType:"css",name:"tailwind-global",transform:Y(tn(n)),buildStart:_,buildEnd:H}}export{Z as PluginOpts,en as default,rn as setPluginConfigurationDefaults,on as tailwindGlobal,sn as tailwindHMR};
//# sourceMappingURL=index.esm.js.map
